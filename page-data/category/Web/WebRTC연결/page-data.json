{"componentChunkName":"component---src-templates-blog-post-js","path":"/category/Web/WebRTC연결/","result":{"data":{"markdownRemark":{"html":"<h1>화상, 음성 채팅 연결</h1>\n<h2>서버</h2>\n<ul>\n<li>mqtt</li>\n</ul>\n<p><a href=\"https://github.com/mqttjs/MQTT.js\">https://github.com/mqttjs/MQTT.js</a></p>\n<p><a href=\"https://github.com/mqttjs/MQTT.js#react:~:text=%3C/html%3E-,React,-npm%20install%20%2Dg\">https://github.com/mqttjs/MQTT.js#react:~:text=</html>-,React,-npm install -g</a></p>\n<h3>QoS</h3>\n<ul>\n<li>QoS 0 : received <strong>at most once</strong> : The packet is sent, and that's it. There is no validation about whether it has been received.</li>\n<li>QoS 1 : received <strong>at least once</strong> : The packet is sent and stored as long as the client has not received a confirmation from the server. MQTT ensures that it <em>will</em> be received, but there can be duplicates.</li>\n<li>QoS 2 : received <strong>exactly once</strong> : Same as QoS 1 but there is no duplicates.</li>\n</ul>\n<h3>버그</h3>\n<ul>\n<li>url 문제\n⇒ 해결 방법\n<a href=\"https://github.com/mqttjs/MQTT.js/issues/1020#issuecomment-565948999\">Unable to resolve module <code>url</code> from `node_modules/mqtt/lib/connect/index.js · Issue #1020 · mqttjs/MQTT.js</a></li>\n<li>User2.js:134 Error adding received ice candidate DOMException: Failed to execute 'addIceCandidate' on 'RTCPeerConnection': The remote description was null 에러\n⇒ 해결방법\n<a href=\"https://velog.io/@njw1204/WebRTC-%EA%B0%84%ED%97%90%EC%A0%81-%EC%97%B0%EA%B2%B0-%EC%8B%A4%ED%8C%A8-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0\">WebRTC 간헐적 연결 실패 문제 해결 (Failed to execute 'addIceCandidate')</a></li>\n</ul>\n<h3>사용방법</h3>\n<ol>\n<li>\n<p>연결(connect)</p>\n<pre><code class=\"language-jsx\">const client = mqtt.connect(DEFAULT_CONNECT_OPTIONS)\n</code></pre>\n</li>\n<li>\n<p>구독(subscribe)</p>\n<pre><code class=\"language-jsx\">client.subscribe(topic/topic array/topic object, [options], [callback])\n</code></pre>\n</li>\n<li>\n<p>발행(publish)</p>\n<pre><code class=\"language-jsx\">mqtt.Client#publish(topic, message, [options], [callback])\n</code></pre>\n</li>\n</ol>\n<p>같은 topic으로 구독을 하고 발행을 하면 topic을 구독하고 있는 곳에서 메시지를 받을 수 있음</p>\n<h2>클라이언트</h2>\n<ul>\n<li>WebRTC</li>\n</ul>\n<h2>작동 순서</h2>\n<ol>\n<li>\n<p>로컬 스트림을 생성하고 사용자의 화면에 띄운다.</p>\n<pre><code class=\"language-jsx\">const myVideoRef= useRef();\nconst localStream = navigator.mediaDevices.getUserMedia({video:true, audio:true})})\nmyVideoRef.current.srcObject = stream;\n</code></pre>\n</li>\n<li>\n<p><code>const peerConnection= new RTCPeerConnection(Option)</code> 생성</p>\n</li>\n<li>\n<p>mqtt 서버를 열고 같은 topic을 구독한다.</p>\n</li>\n<li>\n<p>로컬의 localStream을 peerConnection 객체에 추가한다.</p>\n<pre><code class=\"language-jsx\">localStream.getTracks().forEach(track => {\n  peerConnection.addTrack(track, localStream)\n})\n</code></pre>\n</li>\n<li>\n<p>offer를 만든다.</p>\n<ol>\n<li>⇒ 만든 offer는 peerConnection의 localDescription에 저장한다.</li>\n<li>offer를 mqtt 서버를 통해 보낸다.</li>\n<li>전송할 때 보낸 사람이 누구인지 함께 보내서 자신이 보낸 offer를 저장하지 않게 한다.</li>\n</ol>\n<pre><code class=\"language-jsx\">const offer = peerConnection.createOffer(offerOptions) // 전송자\nclient.publish(\n  \"signal\",\n  JSON.stringify({ offer: offer, username: USER_NAME })\n)\n</code></pre>\n<pre><code class=\"language-jsx\">client.on(\"message\", async (topic, message) => {\n  // 수신자\n  const receivedMsg = JSON.parse(message.toString())\n  if (receivedMsg.answer &#x26;&#x26; receivedMsg.username !== USER_NAME) {\n    peerConnection.setRemoteDescription(\n      new RTCSessionDescription(receivedMsg.answer)\n    )\n  }\n})\n</code></pre>\n<ol>\n<li>수신자는 offer를 받으면 자신의 peerConnection의 remoteDescription에 저장을 한다.\n<ol>\n<li>받</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/49175629/222094266-26113963-e942-4444-b2fe-10d8201aca57.png\" alt=\"image\"></p>\n<h2>간단하게</h2>\n<h3>사전단계</h3>\n<ol>\n<li>mqtt 서버 열고 같은 topic 구독하기</li>\n<li>localStream, peerConnection 객체 생성</li>\n<li>peerConnection에 localStream 객체 추가</li>\n</ol>\n<h3>통신</h3>\n<ul>\n<li>user1\n<ol>\n<li>peerConnection에서 offer를 만듬 ⇒ 만드는 순간 연결가능한 icecandidate들이 생성됨</li>\n<li>offer를 로컬 peerConnection의 setLocalDescription을 사용하여 localDescription으로 지정</li>\n<li>mqtt 서버를 통해 offer를 publish함 ⇒ 보낸사람 이름도 같이 전송(자신이 보낸 offer인것을 구분)</li>\n</ol>\n</li>\n<li>user2\n<ol>\n<li>같은 topic을 구독하고 있던 user2는 message가 offer이고, offer를 보낸 것이 자신이 아니면 setRemoteDescription을 통해 자신의 peerConnection 객체의 remoteDescription으로 추가한다.</li>\n<li>peerConnection.createAnswer를 통해서 answer를 만든다.</li>\n<li>answer를 peerConnection의 localDescription으로 지정</li>\n<li>mqtt 서버로 answer를 publish</li>\n</ol>\n</li>\n<li>user1\n<ol>\n<li>user2가 보낸 answer를 받은 user1은 자신의 remoteDescription에 추가한다.</li>\n</ol>\n</li>\n</ul>\n<p>⇒ 연결 완료</p>\n<h3>이후 작업</h3>\n<p>로컬에서 icecandidate가 발생할 때 감지하는 이벤트 .onicecandidate로 icecandidate를 서버로 전송</p>\n<p>서버에서 듣고 있던 user2는 peerConnection.addIceCandidate로 추가</p>\n<p>상대가 track을 추가하는 것을 감지하는 이벤트 peerConnection.addEventListener(\"track\") 로 추가되면 내 화면의 상대 비디오 부분에 추가</p>","frontmatter":{"title":""}},"allMarkdownRemark":{"group":[{"category":"Algorithm","totalCount":8},{"category":"JavaScript","totalCount":7},{"category":"Problem-Solving","totalCount":25},{"category":"React","totalCount":3},{"category":"Web","totalCount":7}]}},"pageContext":{"slug":"/category/Web/WebRTC연결/"}},"staticQueryHashes":["2885866554"]}