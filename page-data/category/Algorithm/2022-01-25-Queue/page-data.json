{"componentChunkName":"component---src-templates-blog-post-js","path":"/category/Algorithm/2022-01-25-Queue/","result":{"data":{"markdownRemark":{"html":"<h2>알고리즘 강의</h2>\n<h3>1. 큐 만들기(배열)</h3>\n<p> </p>\n<pre><code>class Queue {\n    constructor() {\n        this.queue = [];\n        this.front = 0;\n        this.rear = 0;\n    }\n\n    enqueue(value) {\n        this.queue[this.rear++] = value;\n    }\n\n    dequeue() {\n        const value = this.queue[this.front]; // enqueue처럼 바로 this.front++안한 이유가\n        delete this.queue[this.front]; // dequeue는 값을 리턴해줘야 되는데 값을 저장하고, delete까지 동시에 할 수 없으니까\n        this.front += 1; //value에 리턴해줄 값을 넣어주고, delete로 지워주고, ++해줌.\n        return value;\n    }\n\n    peek() {\n        return this.queue[this.front];\n    }\n\n    size() {\n        return this.rear - this.front;\n    }\n}\n\nconst queue = new Queue();\nqueue.enqueue(1);\nqueue.enqueue(2);\nqueue.enqueue(4);\nconsole.log(queue.dequeue()); // 1 제거\nqueue.enqueue(8);\nconsole.log(queue.size()); // 3\nconsole.log(queue.peek()); // 2\nconsole.log(queue.dequeue()); // 2 제거\nconsole.log(queue.dequeue()); // 4 제거\n</code></pre>\n<p>front와 rear가 무한히 커질수 있다는 단점 존재한다.</p>\n<h3>2. 큐 만들기(리스트)</h3>\n<p> </p>\n<pre><code>class Node {\n    constructor(value) {\n        this.value = value;\n        this.next = null;\n    }\n}\nclass Queue {\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.size = 0;\n    }\n\n    enqueue(newValue) {\n        const newNode = new Node(newValue);\n        if (this.head === null) {\n        this.head = this.tail = newNode;\n        } else {\n        this.tail.next = newNode;\n        this.tail = newNode;\n        }\n        this.size += 1;\n    }\n\n    dequeue() {\n        const value = this.head.value;\n        this.head = this.head.next;\n        this.size -= 1;\n        return value;\n    }\n\n    peek() {\n        return this.head.value;\n    }\n}\n\nconst queue = new Queue();\nqueue.enqueue(1);\nqueue.enqueue(2);\nqueue.enqueue(4);\nconsole.log(queue.dequeue()); // 1 제거\nqueue.enqueue(8);\nconsole.log(queue.size); // 3\nconsole.log(queue.peek()); // 2\nconsole.log(queue.dequeue()); // 2 제거\nconsole.log(queue.dequeue()); // 4 제거\n</code></pre>\n<p>배열 보단 구현이 복잡하다.</p>\n<p>구현할 때 shift함수는 사용하면 안된다.( shift는 선형시간이 걸리기 때문.)</p>\n<h3>3. 원형 큐 만들기 (배열)</h3>\n<p> </p>\n<pre><code>class Queue {\n    constructor(maxSize) {\n        this.maxSize = maxSize;\n        this.queue = [];\n        this.front = 0;\n        this.rear = 0;\n        this.size = 0;\n    }\n\n    enqueue(value) {\n        if (this.isFull()) {\n        console.log(\"Queue is full.\");\n        return;\n        }\n        this.queue[this.rear] = value;\n        this.rear = (this.rear + 1) % this.maxSize;\n        this.size += 1;\n    }\n\n    dequeue() {\n        const value = this.queue[this.front];\n        delete this.queue[this.front];\n        this.front = (this.front + 1) % this.maxSize;\n        this.size -= 1;\n        return value;\n    }\n\n    isFull() {\n        return this.size === this.maxSize;\n    }\n\n    peek() {\n        return this.queue[this.front];\n    }\n}\n\nconst queue = new Queue(4);\nqueue.enqueue(1);\nqueue.enqueue(2);\nqueue.enqueue(4);\nconsole.log(queue.dequeue()); // 1 제거\nqueue.enqueue(8);\nconsole.log(queue.size); // 3\nconsole.log(queue.peek()); // 2\nconsole.log(queue.dequeue()); // 2 제거\nconsole.log(queue.dequeue()); // 4 제거\n</code></pre>\n<p>원형 큐를 사용할 경우가 많지는 않음.</p>","frontmatter":{"title":"Javascript로 Queue 만들기"}},"allMarkdownRemark":{"group":[{"category":"Algorithm","totalCount":8},{"category":"JavaScript","totalCount":7},{"category":"Problem-Solving","totalCount":25},{"category":"React","totalCount":3},{"category":"Web","totalCount":7}]}},"pageContext":{"slug":"/category/Algorithm/2022-01-25-Queue/"}},"staticQueryHashes":["2885866554"]}