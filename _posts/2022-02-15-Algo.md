---
layout: post
title: 코딩테스트 문제 유형 파악
author: Yoo Chang Heon
tags: [Algorithm, Problem-Solving]
---

## 문제를 읽기전에 무조건 입출력 제한을 보자

입력을 살펴보면 어떻게 문제를 풀어야 할지 알 수 있다.

## 입력

### 입력이 100 이하인 경우

- 완전 탐색
- 백트래킹

### 입력이 10,000 이하인 경우

- 최대 O(n^2)이내로 끝내야하는 문제
- 문제에 따라 O(n^2logn)까지는 허용
- n\*n 2차원 리스트를 모두 순회해야 하는 문제가 많음

### 입력이 1,000,000 이하인 경우

- 최대 O(n logn)으로 끝내야 하는 문제
- 힙, 우선순위 큐
- 정렬
- 동적 계획법(DP)
- 위상 정렬
- 다익스트라 알고리즘

### 입력이 100,000,000 이하인 경우

- 최대 O(n)으로 끝내야하는 문제
- 동적 계획법(DP) -그리디

### 그 이상인 경우

- 최대 O(logn)으로 끝내야하는 문제가 많음(거의 나오지 않는 문제 유형)
- 이진탐색

## 문제 유형

### 입력값이 작은 문제

높은 확률로 완전탐색이거나 백트래킹 문제(구현력이 중요한 문제로 출제)

### 지도가 주어지고 채워진 영역을 찾아야 하는 경우

높은 확률로 BFS, DFS 문제.

### 그래프 그림이 있는 경우

- 최단 거리 찾기
- 최소 신장 트리(가장 <b>저렴한</b> 방법으로 모든 경로 연결)
- 위상 정렬 문제(순서를 정해야 할 때! 사용, 순서, 차례 등의 키워드)

### X라는 조건을 만족하는 가장 최대/최소값을 찾아라

높은확률로 결정 문제=> 파라메트릭 서치를 이용

### 실시간으로 정렬이 이뤄져야 하는 경우

높은 확률로 우선순위 큐 혹은 힙을 사용하는 문제

### DP문제

보통 완전탐색처럼 오래걸리면 안되는데 특별한 알고리즘을 사용하는 문제가 아닐거 같을 때

1. 문제를 따라 먼저 초기값을 적는다.
2. 초기값을 포함해 모든 상태값을 적는다.
3. 현재상태를 통해 다음 값을 구할 수 있는지 판단한다.
4. 혹은 이전 상태들을 통해 현재 값을 구할 수 있는지 판단한다. 이런식으로 여러번 해보고 식을 만들 수 있다면 100% DP문제

### 문자열이 주어지는 경우

구현력 문제인 경우가 많다. 문자열을 자르거나 붙이거나 탐색하는 문제가 대부분.

### 현재 상황에서 가장 최적인 선택

"가장 많은 선택, 가장 작은/큰" 등의 키워드=> 그리디 or 최소 신장 트리(이것도 그리디의 일종)
