---
layout: post
title: 웹 브라우저 동작원리
category: [Web]
---

[출처](https://d2.naver.com/helloworld/59361%20)

## 웹 브라우저 동작원리

### 브라우저란?

웹 브라우저는 동기(Synchronous)적으로 (HTML + CSS), Javascript 언어를 해석하여 내용을 화면에 보여주는 응용 소프트웨어입니다.

동기적=> 웹 브라우저가 웹서버에 필요한 자원을 요청하면 서버는 응답하고 웹 브라우저는 이를 해석한 후 사용자에게 보여줌. 보통 자원은 HTML 문서지만 PDF, 이미지 등 다양한 형태일 수 있다.

### 브라우저의 주요 기능

브라우저의 주요기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것.
자원은 보통 HTML문서지만 PDF나 이미지 또는 다른 형태일 수 있다. 자원의 주소는 URI에 의해 정해진다.

브라우저는 HTML 과 CSS 명세에 따라 HTML 파일을 해석해서 표시하는데 이 명세는 웹 표준화 기구인 W3C에서 정한다.

일반적으로

- URI를 입력할 수 있는 주소 표시줄
- 이전 버튼과 다음 버튼
- 북마크
- 새로고침 버튼과 로드 중단할 수 있는 정지 버튼
- 홈버튼

을 가진다.

### 브라우저의 기본 구조

![image](https://user-images.githubusercontent.com/49175629/155922994-1170a224-b8c7-4f51-b16e-79e7fdd6c583.png)

- 사용자 인터페이스: 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.
- 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.
- 렌더링 엔진: 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함.
- 통신: HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행됨.
- UI 백엔드: 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.
- 자바스크립트 해석기: 자바스크립트 코드를 해석하고 실행.
- 자료 저장소: 이 부분은 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 '웹 데이터 베이스'가 정의되어 있다.

### 동작 과정

렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8KB 단위로 전송

#### 렌더링 엔진의 기본적인 동작과정

DOM 트리 구축 위한 HTML 파싱
=> 렌더 트리 구축 => 렌더 트리 배치 => 렌더 트리 그리기

렌더링 엔진은 HTML 문서를 파싱하고 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환 그 다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다. 스타일 정보와 HTML 표시 규칙은 렌더 트리라고 부르는 또 다른 트리를 생성.
렌더트리는 색상 또는 면적과 같은 시각적 속성이 있는 사각형을 포함하고 있는데 정해진 순서대로 화면에 표시.
배치 시작=> 노드가 화면의 정확한 위치에 표시되는 것을 의미. UI 백엔드에서 렌더트리의 각 노들르 가로지르며 형상을 만들어 내는 그리기 과정 거침.

가능한 빠르게 내용을 표시하여 사용자 경험 향상=> 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시.

![image](https://user-images.githubusercontent.com/49175629/155923957-5260e87b-7e7e-4bd0-a5ee-84f65c0c467c.png)

### 파싱과 DOM 트리 구축

문서파싱: 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미. 파싱 결과는 보통 문서구조를 나타내는 노드트리인데 파싱 트리 또는 문법트리라고 부름.

문법: context free grammar(CFG)

파서-어휘 분석기 조합: 파싱은 어휘분석과 구문 분석이라는 두가지로 구분할 수 있다.

- 어휘분석: 자료를 토큰(유효하게 구성된 단위의 집합체)으로 분해하는 과정(ex)단어)
- 구문 분석: 언어의 구문 규칙을 적용하는 과정

파서는 자료를 유효한 토큰으로 분해하는 어휘분석기가 있고, 언어 구문 규칙에 따라 문서 구조를 분석함으로써 파싱 트리를 생성하는 파서가 있다.

문서=> 어휘분석 => 구문분석 => 파싱트리

### HTML 파서

HTML 마크업을 파싱 트리로 변환한다.

모든 전통적인 파서는 HTML에 적용할 수 없다. 파싱은 CSS와 자바스크립트를 파싱하는 데 사용된다.
HTML은 파서가 요구하는 context free grammar로 정의할 수 없다.

HTML은 더 너그럽다. 암묵적으로 태그에 대한 생략이 가능하고, 가끔 시작이나 종료 태그를 생략한다. 이런 차이가 파싱을 어렵게 만들고, 전통적인 구문 분석이 불가능하기 때문에 CFG가 아니라는 것. XML과 유사하지만 XML 파서로도 파싱하기 쉽지 않다.

### DOM (Document Object Model)

파싱트리는 DOM 요소와 속성노드의 트리로서 출력 트리가 된다. 이것은 HTML 문선의 객체 표현이고 외부를 향하는 자바스크립트와 같은 HTML요소의 연결지점. 트리의 최상위 객체는 문서이다.

DOM은 마크업과 1:1 관계를 맺는다.

### HTML 파싱

1. 언어의 너그러운 속성.
   잘 알려져 있는 HTML 오류에 대한 브라우저의 관용.
2. 변경에 의한 재파싱. 일반적으로 소스는 파싱하는 동안 변하지 않지만 HTML에서 document
3. write을 포함하고 있는 스크립트 태그는 토큰을 추가할 수 있기 때문에 실제로는 입력 과정에서 파싱이 수정된다.

HTML은 일반적인 파서로 파싱안됨(이유 상단)=> 별도의 파서 생성

토큰화와 트리구축

토큰화는 어휘분석으로서 입력 값을 토큰으로 파싱(HTML 에서 토큰은 시작태고, 종료태그, 속성이름, 속성 값)
토큰화는 토큰을인지해서 트리 생성자로 넘기고 다른 토큰을 확인하기 위해 다음 문자를 확인한다. 이를 입력의 마지막 까지 반복.

![image](https://user-images.githubusercontent.com/49175629/155925857-f11b4b33-c454-49ab-aa5a-60b5c3e17506.png)

알고리즘의 결과는 HTML 토큰이다. 알고리즘은 상태 기계
각 상태는 하나 이상의 연속된 문자를 입력받아 이문자에 따라 다음 상태를 갱신. 그러나 결과는 현재의 토큰화 상태와 트리구축 상태의 영향을 받는데 이것은 같은 문자를 읽어도 현재 상태에 따라 다음 상태의 결과가 다르게 나온다.

![image](https://user-images.githubusercontent.com/49175629/155926356-05acc1c3-c1b7-417e-b810-51d749ca8a75.png)

### 파싱 이후

이번 단계에서 브라우저는 문서와 상호작용할 수 있게 되고 문서 파싱 이후에 실행되어야 하는 "지연"모드 스크립트를 파싱하기 시작한다. 문서 상태는 "완료"가 되고 "로드" 이벤트가 발생한다.

### CSS 파싱

HTML과 다르게 CSS는 문맥 자유 문법이고, 소개 글에서 설명했던 파서 유형을 이용하여 파싱이 가능하다. 실제로 CSS 명세는 CSS 어휘와 문법을 정의하고 있다.

### 스크립트와 스타일 시트의 진행 순서

#### 스크립트

웹은 파싱과 실행이 동시에 수행되는 동기화(synchronous) 모델이다. 제작자는 파서가 < script > 태그를 만나면 즉시 파싱하고 실행하기를 기대한다. 스크립트가 실행되는 동안 문서의 파싱은 중단된다. 스크립트가 외부에 있는 경우 우선 네트워크로부터 자원을 가져와야 하는데 이 또한 실시간으로 처리되고 자원을 받을 때까지 파싱은 중단된다. 이 모델은 수 년간 지속됐고 HTML4와 HTML5의 명세에도 정의되어 있다. 제작자는 스크립트를 "지연(defer)"으로 표시할 수 있는데 지연으로 표시하게 되면 문서 파싱은 중단되지 않고 문서 파싱이 완료된 이후에 스크립트가 실행된다. HTML5는 스크립트를 비동기(asynchronous)로 처리하는 속성을 추가했기 때문에 별도의 맥락에 의해 파싱되고 실행된다.

#### 예측 파싱

웹킷과 파이어폭스는 예측 파싱과 같은 최적화를 지원한다. 스크립트를 실행하는 동안 다른 스레드는 네트워크로부터 다른 자원을 찾아 내려받고 문서의 나머지 부분을 파싱한다. 이런 방법은 자원을 병렬로 연결하여 받을 수 있고 전체적인 속도를 개선한다. 참고로 예측 파서는 DOM 트리를 수정하지 않고 메인 파서의 일로 넘긴다. 예측 파서는 외부 스크립트, 외부 스타일 시트와 외부 이미지와 같이 참조된 외부 자원을 파싱할 뿐이다.

#### 스타일 시트

한편 스타일 시트는 다른 모델을 사용한다. 이론적으로 스타일 시트는 DOM 트리를 변경하지 않기 때문에 문서 파싱을 기다리거나 중단할 이유가 없다. 그러나 스크립트가 문서를 파싱하는 동안 스타일 정보를 요청하는 경우라면 문제가 된다. 스타일이 파싱되지 않은 상태라면 스크립트는 잘못된 결과를 내놓기 때문에 많은 문제를 야기한다. 이런 문제는 흔치 않은 것처럼 보이지만 매우 빈번하게 발생한다. 파이어폭스는 아직 로드 중이거나 파싱 중인 스타일 시트가 있는 경우 모든 스크립트의 실행을 중단한다. 한편 웹킷은 로드되지 않은 스타일 시트 가운데 문제가 될만한 속성이 있을 때에만 스크립트를 중단한다.

## 렌더 트리 구축

DOM 트리가 구축되는 동안 브라우저는 렌더 트리를 구축한다. 표시해야 할 순서와 문서의 시각적인 구성요소로써 올바른 순서로 내용을 그려낼 수 있도록 하기 위한 목적이 있다.
이는 자신과 자식 요소를 어떻게 배치하고 그려내야 하는지 알고있다.

## DOM 트리와 렌더 트리의 관계

렌더러는 DOM 요소에 부합하지만 1:1로 대응하는 관계는 아니다.예를 들어 head같은 비시각적 DOM 요소는 렌더트리에 추가 되지 않는다. display: none도 트리에 나타나지 않음(visibility: hidden은 트리에 나타남)

## 트리를 구축하는 과정

파이어폭스에서 프레젠테이션은 DOM 업데이트를 위한 리스너로 등록된다. 프레젠테이션은 형상 만들기를 FrameConstructor에 위임하고 FrameConstructor는 스타일(스타일 계산 참고)을 결정하고 형상을 만든다.

웹킷에서는 스타일을 결정하고 렌더러를 만드는 과정을 "어태치먼트(attachment)" 라고 부른다. 모든 DOM 노드에는 "attach" 메서드가 있다. 어태치먼트는 동기적인데 DOM 트리에 노드를 추가하면 새 노드의 "attach" 메서드를 호출한다.

## 스타일 계산

렌더트리를 구축하려면 각 렌더 객체의 시각적 속성에 대한 계산이 필요=> 각 요소의 스타일 속성을 계산함으로써 처리

최초의 스타일 시트는 브라우저가 제공하는 기본 스타일 시트인데 페이지 제작자 또는 사용자도 이를 제공할 수 있다.

스타일 계산의 어려움

1. 스타일 데이터는 구성이 매우 광범위한데 수많은 스타일 속성들을 수용하면서 메모리 문제를 야기 할 수 있다.
2. 최적화되어 있지 않다면 각 요소에 할당된 규칙을 찾는 것은 성능 문제를 야기할 수 있다.
3. 규칙을 적용하는 것은 계층 구조를 파악해야 하는 복잡한 다단계 규칙을 수반.

## 배치

렌더러가 생성되어 트리에 추가될 때 크기와 위치 정보는 없는데 이런 값을 게산하는 것을 배치 또는 리플로라고 부른다.

HTML은 흐름기반의 배치 모델을 사용하는데 이것은 보통 단일 경로를 통해 크기와 위치 정보를 계산할 수 있다는 것을 의미한다. 일반적으로 흐름 속에서 나중에 등장하는 요소는 앞서 등장한 요소의 위치와 크기에 영향을 미치지 않으므로 배치는 왼쪽에서 오른쪽 또는 위에서 아래로 흐른다.(표는 예외)

## 결론

1. HTML 문서를 파싱하여 DOM 트리 구축
2. CSSOM을 생성
3. 렌더 트리(DOM+ CSSOM)를 생성

   DOM 트리가 구축되는 동안 브라우저는 DOM 트리를 기반으로 렌더 트리를 생성. 렌더 트리는 문서를 시각적인 구성 요소로 만들어 줌.

4. 렌더 트리 배치

   렌더 트리는 위치와 크기x=> 어느 공간에 위치해야 할지 각 객체들에게 위치와 크기를 결정해줌.

5. 렌더 트리 그림

   렌더 트리가 만들어져 레이아웃이 구성되었으면 UI 백엔드가 동작하여 각 객체를 픽셀 값으로 나타냄.

JS는 자바스크립트 엔진이 처리
=> \<script>태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 권한 넘김
==> Javascript코드를 body태그 아래에 위치시키는 이유
(완성되지 않은 DOM을 조작하면 에러발생)
